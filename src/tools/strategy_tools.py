"""Strategy management tools for MCP server."""

from typing import Any

from mcp.server.fastmcp import FastMCP
from pydantic import BaseModel, Field

from src.db.card_repository import CardRepository
from src.db.strategy_repository import StrategyRepository
from src.models.strategy import Attachment, Strategy
from src.tools.errors import (
    ErrorCode,
    StructuredToolError,
    not_found_error,
    validation_error,
)

# Valid roles for card attachments
VALID_ROLES = ["signal", "gate", "exit", "sizing", "risk", "overlay"]
VALID_STATUSES = ["draft", "ready", "running", "paused", "stopped", "error"]


class CreateStrategyResponse(BaseModel):
    """Response from create_strategy tool."""

    strategy_id: str = Field(..., description="Generated strategy identifier")
    name: str = Field(..., description="Strategy name")
    status: str = Field(..., description="Strategy status")
    universe: list[str] = Field(..., description="Trading universe")
    attachments: list[dict[str, Any]] = Field(..., description="Attached cards")
    version: int = Field(..., description="Strategy version")
    created_at: str = Field(..., description="ISO8601 timestamp of creation")


class GetStrategyResponse(BaseModel):
    """Response from get_strategy tool."""

    strategy_id: str = Field(..., description="Strategy identifier")
    owner_id: str | None = Field(None, description="Owner identifier")
    name: str = Field(..., description="Strategy name")
    status: str = Field(..., description="Strategy status")
    universe: list[str] = Field(..., description="Trading universe")
    attachments: list[dict[str, Any]] = Field(..., description="Attached cards")
    version: int = Field(..., description="Strategy version")
    created_at: str = Field(..., description="ISO8601 timestamp of creation")
    updated_at: str = Field(..., description="ISO8601 timestamp of last update")


class UpdateStrategyMetaResponse(BaseModel):
    """Response from update_strategy_meta tool."""

    strategy_id: str = Field(..., description="Strategy identifier")
    name: str = Field(..., description="Strategy name")
    status: str = Field(..., description="Strategy status")
    universe: list[str] = Field(..., description="Trading universe")
    version: int = Field(..., description="Strategy version")
    updated_at: str = Field(..., description="ISO8601 timestamp of last update")


class AttachCardResponse(BaseModel):
    """Response from attach_card tool."""

    strategy_id: str = Field(..., description="Strategy identifier")
    attachments: list[dict[str, Any]] = Field(..., description="Updated attachments list")
    version: int = Field(..., description="Strategy version")
    updated_at: str = Field(..., description="ISO8601 timestamp of last update")


class DetachCardResponse(BaseModel):
    """Response from detach_card tool."""

    strategy_id: str = Field(..., description="Strategy identifier")
    attachments: list[dict[str, Any]] = Field(..., description="Updated attachments list")
    version: int = Field(..., description="Strategy version")
    updated_at: str = Field(..., description="ISO8601 timestamp of last update")


class ListStrategiesResponse(BaseModel):
    """Response from list_strategies tool."""

    strategies: list[dict[str, Any]] = Field(..., description="List of strategies")
    count: int = Field(..., description="Total number of strategies")


def register_strategy_tools(
    mcp: FastMCP,
    strategy_repo: StrategyRepository,
    card_repo: CardRepository,
) -> None:
    """Register all strategy management tools with the MCP server.

    Dependencies are injected so tests and callers can control which
    repositories (and therefore which databases/backends) are used.
    """

    @mcp.tool()
    def create_strategy(
        name: str = Field(..., description="Strategy name"),
        owner_id: str | None = Field(None, description="Owner identifier (optional)"),
        universe: list[str] = Field(  # noqa: B008
            default_factory=list, description="Trading universe symbols"
        ),
    ) -> CreateStrategyResponse:
        """
        Create a new trading strategy.

        A strategy is a composition of cards (signals, gates, exits, etc.) with
        universe selection. Risk and execution parameters are configured when
        the strategy is run, not at creation time.

        Recommended workflow:
        1. Create cards using create_card tool
        2. Create strategy with create_strategy
        3. Attach cards to strategy using attach_card

        Args:
            name: Strategy name
            owner_id: Owner identifier (optional)
            universe: List of trading symbols (e.g., ['BTC-USD'])

        Returns:
            CreateStrategyResponse with generated strategy_id and initial configuration
        """
        # Create strategy
        strategy = Strategy(
            id="",  # Will be generated by Firestore
            owner_id=owner_id,
            name=name,
            status="draft",
            universe=universe,
            attachments=[],
            version=1,
            created_at="",  # Will be set by repository
            updated_at="",  # Will be set by repository
        )

        created_strategy = strategy_repo.create(strategy)

        return CreateStrategyResponse(
            strategy_id=created_strategy.id,
            name=created_strategy.name,
            status=created_strategy.status,
            universe=created_strategy.universe,
            attachments=[att.model_dump() for att in created_strategy.attachments],
            version=created_strategy.version,
            created_at=created_strategy.created_at,
        )

    @mcp.tool()
    def get_strategy(
        strategy_id: str = Field(..., description="Strategy identifier"),
    ) -> GetStrategyResponse:
        """
        Get a strategy by ID.

        Args:
            strategy_id: Strategy identifier

        Returns:
            GetStrategyResponse with strategy data

        Raises:
            StructuredToolError: With error code STRATEGY_NOT_FOUND if strategy not found (non-retryable)

        Error Handling:
            Errors include structured information with error_code, retryable flag,
            recovery_hint, and details for agentic decision-making.
        """
        strategy = strategy_repo.get_by_id(strategy_id)
        if strategy is None:
            raise not_found_error(
                resource_type="Strategy",
                resource_id=strategy_id,
                recovery_hint="Use list_strategies to see all available strategies.",
            )

        return GetStrategyResponse(
            strategy_id=strategy.id,
            owner_id=strategy.owner_id,
            name=strategy.name,
            status=strategy.status,
            universe=strategy.universe,
            attachments=[att.model_dump() for att in strategy.attachments],
            version=strategy.version,
            created_at=strategy.created_at,
            updated_at=strategy.updated_at,
        )

    @mcp.tool()
    def update_strategy_meta(
        strategy_id: str = Field(..., description="Strategy identifier"),
        name: str | None = Field(None, description="Strategy name (optional)"),
        status: str | None = Field(None, description="Strategy status (optional)"),
        universe: list[str] | None = Field(None, description="Trading universe (optional)"),  # noqa: B008
    ) -> UpdateStrategyMetaResponse:
        """
        Update strategy metadata.

        Updates only the fields provided. Other fields remain unchanged.

        Args:
            strategy_id: Strategy identifier
            name: Strategy name (optional)
            status: Strategy status: draft, ready, running, paused, stopped, error (optional)
            universe: Trading universe symbols (optional)

        Returns:
            UpdateStrategyMetaResponse with updated strategy data

        Raises:
            StructuredToolError: With error codes:
                - STRATEGY_NOT_FOUND: If strategy not found (non-retryable)
                - INVALID_STATUS: If status is invalid (non-retryable)
        """
        # Get existing strategy
        strategy = strategy_repo.get_by_id(strategy_id)
        if strategy is None:
            raise not_found_error(
                resource_type="Strategy",
                resource_id=strategy_id,
                recovery_hint="Use list_strategies to see all available strategies.",
            )

        # Validate status if provided
        if status is not None and status not in VALID_STATUSES:
            raise StructuredToolError(
                message=f"Invalid status: {status}. Must be one of: {VALID_STATUSES}.",
                error_code=ErrorCode.INVALID_STATUS,
                retryable=False,
                recovery_hint=f"Use one of: {', '.join(VALID_STATUSES)}",
                details={"provided_status": status, "valid_statuses": VALID_STATUSES},
            )

        # Update only provided fields
        if name is not None:
            strategy.name = name
        if status is not None:
            strategy.status = status
        if universe is not None:
            strategy.universe = universe

        updated_strategy = strategy_repo.update(strategy)

        return UpdateStrategyMetaResponse(
            strategy_id=updated_strategy.id,
            name=updated_strategy.name,
            status=updated_strategy.status,
            universe=updated_strategy.universe,
            version=updated_strategy.version,
            updated_at=updated_strategy.updated_at,
        )

    @mcp.tool()
    def attach_card(
        strategy_id: str = Field(..., description="Strategy identifier"),
        card_id: str = Field(..., description="Card identifier to attach"),
        role: str = Field(
            ...,
            description="Card role: signal, gate, exit, sizing, risk, or overlay",
        ),
        overrides: dict[str, Any] = Field(  # noqa: B008
            default_factory=dict, description="Slot value overrides (optional)"
        ),
        follow_latest: bool = Field(
            default=False,
            description="If true, use latest card version; if false, pin current version",
        ),
        order: int | None = Field(
            None,
            description="Execution order (optional, auto-assigned if not provided)",
        ),
        enabled: bool = Field(default=True, description="Whether attachment is enabled"),
    ) -> AttachCardResponse:
        """
        Attach a card to a strategy.

        Cards can be attached with different roles (signal, gate, exit, etc.) and
        optional slot overrides. The attachment can follow the latest card version
        or be pinned to a specific version.

        Recommended workflow:
        1. Create cards using create_card
        2. Create strategy using create_strategy
        3. Attach cards using attach_card with appropriate roles

        Args:
            strategy_id: Strategy identifier
            card_id: Card identifier to attach
            role: Card role (signal, gate, exit, sizing, risk, or overlay)
            overrides: Slot value overrides to merge with card slots (optional)
            follow_latest: If true, use latest card version; if false, pin current version
            order: Execution order (optional, auto-assigned to next available)
            enabled: Whether attachment is enabled (default: true)

        Returns:
            AttachCardResponse with updated attachments list

        Raises:
            StructuredToolError: With error codes:
                - INVALID_ROLE: If role is invalid (non-retryable)
                - STRATEGY_NOT_FOUND: If strategy not found (non-retryable)
                - CARD_NOT_FOUND: If card not found (non-retryable)
                - DUPLICATE_ATTACHMENT: If card is already attached (non-retryable)

        Error Handling:
            All errors include structured information with error_code, retryable flag,
            recovery_hint, and details for agentic decision-making.
        """
        # Validate role
        if role not in VALID_ROLES:
            raise StructuredToolError(
                message=f"Invalid role: {role}. Must be one of: {VALID_ROLES}.",
                error_code=ErrorCode.INVALID_ROLE,
                retryable=False,
                recovery_hint=f"Use one of: {', '.join(VALID_ROLES)}. Use get_strategy to see current attachments.",
                details={"provided_role": role, "valid_roles": VALID_ROLES},
            )

        # Get strategy
        strategy = strategy_repo.get_by_id(strategy_id)
        if strategy is None:
            raise not_found_error(
                resource_type="Strategy",
                resource_id=strategy_id,
                recovery_hint="Use list_strategies to see all available strategies.",
            )

        # Verify card exists
        card = card_repo.get_by_id(card_id)
        if card is None:
            raise not_found_error(
                resource_type="Card",
                resource_id=card_id,
                recovery_hint="Use list_cards to see all available cards.",
            )

        # Check if card is already attached
        for att in strategy.attachments:
            if att.card_id == card_id:
                raise validation_error(
                    message=f"Card {card_id} is already attached to strategy {strategy_id}.",
                    recovery_hint="Use detach_card first to remove it, or update the attachment manually.",
                    details={"card_id": card_id, "strategy_id": strategy_id},
                )

        # Determine order (auto-assign if not provided)
        if order is None:
            if strategy.attachments:
                max_order = max(att.order for att in strategy.attachments)
                order = max_order + 1
            else:
                order = 1

        # Determine card_revision_id (use updated_at as simple revision identifier for MVP)
        card_revision_id = None
        if not follow_latest:
            card_revision_id = card.updated_at  # Simple revision ID for MVP

        # Create attachment
        attachment = Attachment(
            card_id=card_id,
            role=role,
            order=order,
            enabled=enabled,
            overrides=overrides,
            follow_latest=follow_latest,
            card_revision_id=card_revision_id,
        )

        # Add attachment to strategy
        strategy.attachments.append(attachment)
        updated_strategy = strategy_repo.update(strategy)

        return AttachCardResponse(
            strategy_id=updated_strategy.id,
            attachments=[att.model_dump() for att in updated_strategy.attachments],
            version=updated_strategy.version,
            updated_at=updated_strategy.updated_at,
        )

    @mcp.tool()
    def detach_card(
        strategy_id: str = Field(..., description="Strategy identifier"),
        card_id: str = Field(..., description="Card identifier to detach"),
    ) -> DetachCardResponse:
        """
        Detach a card from a strategy.

        Args:
            strategy_id: Strategy identifier
            card_id: Card identifier to detach

        Returns:
            DetachCardResponse with updated attachments list

        Raises:
            StructuredToolError: With error codes:
                - STRATEGY_NOT_FOUND: If strategy not found (non-retryable)
                - ATTACHMENT_NOT_FOUND: If card is not attached (non-retryable)
        """
        # Get strategy
        strategy = strategy_repo.get_by_id(strategy_id)
        if strategy is None:
            raise not_found_error(
                resource_type="Strategy",
                resource_id=strategy_id,
                recovery_hint="Use list_strategies to see all available strategies.",
            )

        # Find and remove attachment
        original_count = len(strategy.attachments)
        strategy.attachments = [att for att in strategy.attachments if att.card_id != card_id]

        if len(strategy.attachments) == original_count:
            raise validation_error(
                message=f"Card {card_id} is not attached to strategy {strategy_id}.",
                recovery_hint="Use get_strategy to see current attachments.",
                details={"card_id": card_id, "strategy_id": strategy_id},
            )

        updated_strategy = strategy_repo.update(strategy)

        return DetachCardResponse(
            strategy_id=updated_strategy.id,
            attachments=[att.model_dump() for att in updated_strategy.attachments],
            version=updated_strategy.version,
            updated_at=updated_strategy.updated_at,
        )

    @mcp.tool()
    def list_strategies() -> ListStrategiesResponse:
        """
        List all strategies.

        Returns:
            ListStrategiesResponse with all strategies
        """
        strategies = strategy_repo.get_all()
        strategy_dicts = []
        for strategy in strategies:
            strategy_dicts.append(
                {
                    "strategy_id": strategy.id,
                    "owner_id": strategy.owner_id,
                    "name": strategy.name,
                    "status": strategy.status,
                    "universe": strategy.universe,
                    "attachments_count": len(strategy.attachments),
                    "version": strategy.version,
                    "created_at": strategy.created_at,
                    "updated_at": strategy.updated_at,
                }
            )

        return ListStrategiesResponse(strategies=strategy_dicts, count=len(strategy_dicts))
